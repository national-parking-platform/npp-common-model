package org.npp.model.rate;
  
import java.net.URI;
import java.util.Objects;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonSubTypes;
import com.fasterxml.jackson.annotation.JsonTypeInfo;
import com.fasterxml.jackson.annotation.JsonValue;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.npp.model.rate.RateLine;
import org.openapitools.jackson.nullable.JsonNullable;
import java.time.OffsetDateTime;
import jakarta.validation.Valid;
import jakarta.validation.constraints.*;
import io.swagger.v3.oas.annotations.media.Schema;
import java.util.*;
import jakarta.annotation.Generated;

/**
 * A group of rate line elements that logically group together within one rate table,  e.g. such as the rate lines for the different tiers of a time-based tier rate table.
 */

@Schema(name = "RateLineCollection", description = "A group of rate line elements that logically group together within one rate table,  e.g. such as the rate lines for the different tiers of a time-based tier rate table.")
@JsonIgnoreProperties(
  value = "rateLineCollectionType", // ignore manually set rateLineCollectionType, it will be automatically generated by Jackson during serialization
  allowSetters = true // allows the rateLineCollectionType to be set during deserialization
)
@JsonTypeInfo(use = JsonTypeInfo.Id.NAME, include = JsonTypeInfo.As.PROPERTY, property = "rateLineCollectionType", visible = true)
@JsonSubTypes({
  @JsonSubTypes.Type(value = RateLineCollectionAbsoluteTimes.class, name = "RateLineCollectionAbsoluteTimes"),
  @JsonSubTypes.Type(value = RateLineCollectionRelativeTimes.class, name = "RateLineCollectionRelativeTimes")
})


public class RateLineCollection {

  /**
   * Gets or Sets rateLineCollectionType
   */
  public enum RateLineCollectionTypeEnum {
    RATELINECOLLECTIONABSOLUTETIMES("RateLineCollectionAbsoluteTimes"),
    
    RATELINECOLLECTIONRELATIVETIMES("RateLineCollectionRelativeTimes");

    private String value;

    RateLineCollectionTypeEnum(String value) {
      this.value = value;
    }

    @JsonValue
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    @JsonCreator
    public static RateLineCollectionTypeEnum fromValue(String value) {
      for (RateLineCollectionTypeEnum b : RateLineCollectionTypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }
  }

  private RateLineCollectionTypeEnum rateLineCollectionType;

  private String applicableCurrency;

  private Integer collectionSequence;

  private String minTime;

  private String maxTime;

  private Float minValueCollection;

  private Float maxValueCollection;

  private Boolean relativeTimes;

  private String resetTime;

  private Boolean taxIncluded;

  private Float taxRate;

  private Float taxValue;

  @Valid
  private List<@Valid RateLine> rateLines = new ArrayList<>();

  public RateLineCollection() {
    super();
  }

  /**
   * Constructor with only required parameters
   */
  public RateLineCollection(RateLineCollectionTypeEnum rateLineCollectionType, String applicableCurrency, Integer collectionSequence, String minTime, String maxTime, Boolean relativeTimes, String resetTime, Boolean taxIncluded, List<@Valid RateLine> rateLines) {
    this.rateLineCollectionType = rateLineCollectionType;
    this.applicableCurrency = applicableCurrency;
    this.collectionSequence = collectionSequence;
    this.minTime = minTime;
    this.maxTime = maxTime;
    this.relativeTimes = relativeTimes;
    this.resetTime = resetTime;
    this.taxIncluded = taxIncluded;
    this.rateLines = rateLines;
  }

  public RateLineCollection rateLineCollectionType(RateLineCollectionTypeEnum rateLineCollectionType) {
    this.rateLineCollectionType = rateLineCollectionType;
    return this;
  }

  /**
   * Get rateLineCollectionType
   * @return rateLineCollectionType
  */
  @NotNull 
  @Schema(name = "rateLineCollectionType", requiredMode = Schema.RequiredMode.REQUIRED)
  @JsonProperty("rateLineCollectionType")
  public RateLineCollectionTypeEnum getRateLineCollectionType() {
    return rateLineCollectionType;
  }

  public void setRateLineCollectionType(RateLineCollectionTypeEnum rateLineCollectionType) {
    this.rateLineCollectionType = rateLineCollectionType;
  }

  public RateLineCollection applicableCurrency(String applicableCurrency) {
    this.applicableCurrency = applicableCurrency;
    return this;
  }

  /**
   * Code for the specified currency as defined in ISO 4217.
   * @return applicableCurrency
  */
  @NotNull @Pattern(regexp = "^[A-Z]{3}$") 
  @Schema(name = "applicableCurrency", example = "EUR", description = "Code for the specified currency as defined in ISO 4217.", requiredMode = Schema.RequiredMode.REQUIRED)
  @JsonProperty("applicableCurrency")
  public String getApplicableCurrency() {
    return applicableCurrency;
  }

  public void setApplicableCurrency(String applicableCurrency) {
    this.applicableCurrency = applicableCurrency;
  }

  public RateLineCollection collectionSequence(Integer collectionSequence) {
    this.collectionSequence = collectionSequence;
    return this;
  }

  /**
   * An indicator giving the place in sequence of this rate line collection.
   * minimum: 1
   * @return collectionSequence
  */
  @NotNull @Min(1) 
  @Schema(name = "collectionSequence", description = "An indicator giving the place in sequence of this rate line collection.", requiredMode = Schema.RequiredMode.REQUIRED)
  @JsonProperty("collectionSequence")
  public Integer getCollectionSequence() {
    return collectionSequence;
  }

  public void setCollectionSequence(Integer collectionSequence) {
    this.collectionSequence = collectionSequence;
  }

  public RateLineCollection minTime(String minTime) {
    this.minTime = minTime;
    return this;
  }

  /**
   * ISO8601 format definition of an interval of time in format [PnnYnnMnnDTnnHnnMnnS].
   * @return minTime
  */
  @NotNull @Pattern(regexp = "^P(?!$)(\\d+Y)?(\\d+M)?(\\d+W)?(\\d+D)?(T(?=\\d)(\\d+H)?(\\d+M)?(\\d+S)?)?$") 
  @Schema(name = "minTime", example = "P1Y2M3DT4H5M6S", description = "ISO8601 format definition of an interval of time in format [PnnYnnMnnDTnnHnnMnnS].", requiredMode = Schema.RequiredMode.REQUIRED)
  @JsonProperty("minTime")
  public String getMinTime() {
    return minTime;
  }

  public void setMinTime(String minTime) {
    this.minTime = minTime;
  }

  public RateLineCollection maxTime(String maxTime) {
    this.maxTime = maxTime;
    return this;
  }

  /**
   * ISO8601 format definition of an interval of time in format [PnnYnnMnnDTnnHnnMnnS].
   * @return maxTime
  */
  @NotNull @Pattern(regexp = "^P(?!$)(\\d+Y)?(\\d+M)?(\\d+W)?(\\d+D)?(T(?=\\d)(\\d+H)?(\\d+M)?(\\d+S)?)?$") 
  @Schema(name = "maxTime", example = "P1Y2M3DT4H5M6S", description = "ISO8601 format definition of an interval of time in format [PnnYnnMnnDTnnHnnMnnS].", requiredMode = Schema.RequiredMode.REQUIRED)
  @JsonProperty("maxTime")
  public String getMaxTime() {
    return maxTime;
  }

  public void setMaxTime(String maxTime) {
    this.maxTime = maxTime;
  }

  public RateLineCollection minValueCollection(Float minValueCollection) {
    this.minValueCollection = minValueCollection;
    return this;
  }

  /**
   * FIXME: The minimum monetary amount to be applied in conjunction with use of this rate line collection.
   * @return minValueCollection
  */
  
  @Schema(name = "minValueCollection", description = "FIXME: The minimum monetary amount to be applied in conjunction with use of this rate line collection.", requiredMode = Schema.RequiredMode.NOT_REQUIRED)
  @JsonProperty("minValueCollection")
  public Float getMinValueCollection() {
    return minValueCollection;
  }

  public void setMinValueCollection(Float minValueCollection) {
    this.minValueCollection = minValueCollection;
  }

  public RateLineCollection maxValueCollection(Float maxValueCollection) {
    this.maxValueCollection = maxValueCollection;
    return this;
  }

  /**
   * FIXME: The maximum monetary amount to be applied in conjunction with use of this rate line collection.
   * @return maxValueCollection
  */
  
  @Schema(name = "maxValueCollection", description = "FIXME: The maximum monetary amount to be applied in conjunction with use of this rate line collection.", requiredMode = Schema.RequiredMode.NOT_REQUIRED)
  @JsonProperty("maxValueCollection")
  public Float getMaxValueCollection() {
    return maxValueCollection;
  }

  public void setMaxValueCollection(Float maxValueCollection) {
    this.maxValueCollection = maxValueCollection;
  }

  public RateLineCollection relativeTimes(Boolean relativeTimes) {
    this.relativeTimes = relativeTimes;
    return this;
  }

  /**
   * [TRUE] Indicates whether times relative to the start of an event are used as the basis for rate calculation.  [FALSE] indicates that parking rate calculation definitions are done with respect to the parking sessions and defined local or UTC times.
   * @return relativeTimes
  */
  @NotNull 
  @Schema(name = "relativeTimes", description = "[TRUE] Indicates whether times relative to the start of an event are used as the basis for rate calculation.  [FALSE] indicates that parking rate calculation definitions are done with respect to the parking sessions and defined local or UTC times.", requiredMode = Schema.RequiredMode.REQUIRED)
  @JsonProperty("relativeTimes")
  public Boolean getRelativeTimes() {
    return relativeTimes;
  }

  public void setRelativeTimes(Boolean relativeTimes) {
    this.relativeTimes = relativeTimes;
  }

  public RateLineCollection resetTime(String resetTime) {
    this.resetTime = resetTime;
    return this;
  }

  /**
   * Time that rate resets
   * @return resetTime
  */
  @NotNull 
  @Schema(name = "resetTime", description = "Time that rate resets", requiredMode = Schema.RequiredMode.REQUIRED)
  @JsonProperty("resetTime")
  public String getResetTime() {
    return resetTime;
  }

  public void setResetTime(String resetTime) {
    this.resetTime = resetTime;
  }

  public RateLineCollection taxIncluded(Boolean taxIncluded) {
    this.taxIncluded = taxIncluded;
    return this;
  }

  /**
   * [TRUE] Indication that tax to be applied is included within the total rate associated with this rate line collection.  [FALSE] Indicates that the tax is added additionally to the total.
   * @return taxIncluded
  */
  @NotNull 
  @Schema(name = "taxIncluded", description = "[TRUE] Indication that tax to be applied is included within the total rate associated with this rate line collection.  [FALSE] Indicates that the tax is added additionally to the total.", requiredMode = Schema.RequiredMode.REQUIRED)
  @JsonProperty("taxIncluded")
  public Boolean getTaxIncluded() {
    return taxIncluded;
  }

  public void setTaxIncluded(Boolean taxIncluded) {
    this.taxIncluded = taxIncluded;
  }

  public RateLineCollection taxRate(Float taxRate) {
    this.taxRate = taxRate;
    return this;
  }

  /**
   * The percentage rate of tax to be applied.
   * minimum: 0
   * maximum: 100
   * @return taxRate
  */
  @DecimalMin("0") @DecimalMax("100") 
  @Schema(name = "taxRate", description = "The percentage rate of tax to be applied.", requiredMode = Schema.RequiredMode.NOT_REQUIRED)
  @JsonProperty("taxRate")
  public Float getTaxRate() {
    return taxRate;
  }

  public void setTaxRate(Float taxRate) {
    this.taxRate = taxRate;
  }

  public RateLineCollection taxValue(Float taxValue) {
    this.taxValue = taxValue;
    return this;
  }

  /**
   * The monetary amount of tax to be applied.
   * @return taxValue
  */
  
  @Schema(name = "taxValue", description = "The monetary amount of tax to be applied.", requiredMode = Schema.RequiredMode.NOT_REQUIRED)
  @JsonProperty("taxValue")
  public Float getTaxValue() {
    return taxValue;
  }

  public void setTaxValue(Float taxValue) {
    this.taxValue = taxValue;
  }

  public RateLineCollection rateLines(List<@Valid RateLine> rateLines) {
    this.rateLines = rateLines;
    return this;
  }

  public RateLineCollection addRateLinesItem(RateLine rateLinesItem) {
    if (this.rateLines == null) {
      this.rateLines = new ArrayList<>();
    }
    this.rateLines.add(rateLinesItem);
    return this;
  }

  /**
   * Get rateLines
   * @return rateLines
  */
  @NotNull @Valid @Size(min = 1) 
  @Schema(name = "rateLines", requiredMode = Schema.RequiredMode.REQUIRED)
  @JsonProperty("rateLines")
  public List<@Valid RateLine> getRateLines() {
    return rateLines;
  }

  public void setRateLines(List<@Valid RateLine> rateLines) {
    this.rateLines = rateLines;
  }

  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    RateLineCollection rateLineCollection = (RateLineCollection) o;
    return Objects.equals(this.rateLineCollectionType, rateLineCollection.rateLineCollectionType) &&
        Objects.equals(this.applicableCurrency, rateLineCollection.applicableCurrency) &&
        Objects.equals(this.collectionSequence, rateLineCollection.collectionSequence) &&
        Objects.equals(this.minTime, rateLineCollection.minTime) &&
        Objects.equals(this.maxTime, rateLineCollection.maxTime) &&
        Objects.equals(this.minValueCollection, rateLineCollection.minValueCollection) &&
        Objects.equals(this.maxValueCollection, rateLineCollection.maxValueCollection) &&
        Objects.equals(this.relativeTimes, rateLineCollection.relativeTimes) &&
        Objects.equals(this.resetTime, rateLineCollection.resetTime) &&
        Objects.equals(this.taxIncluded, rateLineCollection.taxIncluded) &&
        Objects.equals(this.taxRate, rateLineCollection.taxRate) &&
        Objects.equals(this.taxValue, rateLineCollection.taxValue) &&
        Objects.equals(this.rateLines, rateLineCollection.rateLines);
  }

  @Override
  public int hashCode() {
    return Objects.hash(rateLineCollectionType, applicableCurrency, collectionSequence, minTime, maxTime, minValueCollection, maxValueCollection, relativeTimes, resetTime, taxIncluded, taxRate, taxValue, rateLines);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class RateLineCollection {\n");
    sb.append("    rateLineCollectionType: ").append(toIndentedString(rateLineCollectionType)).append("\n");
    sb.append("    applicableCurrency: ").append(toIndentedString(applicableCurrency)).append("\n");
    sb.append("    collectionSequence: ").append(toIndentedString(collectionSequence)).append("\n");
    sb.append("    minTime: ").append(toIndentedString(minTime)).append("\n");
    sb.append("    maxTime: ").append(toIndentedString(maxTime)).append("\n");
    sb.append("    minValueCollection: ").append(toIndentedString(minValueCollection)).append("\n");
    sb.append("    maxValueCollection: ").append(toIndentedString(maxValueCollection)).append("\n");
    sb.append("    relativeTimes: ").append(toIndentedString(relativeTimes)).append("\n");
    sb.append("    resetTime: ").append(toIndentedString(resetTime)).append("\n");
    sb.append("    taxIncluded: ").append(toIndentedString(taxIncluded)).append("\n");
    sb.append("    taxRate: ").append(toIndentedString(taxRate)).append("\n");
    sb.append("    taxValue: ").append(toIndentedString(taxValue)).append("\n");
    sb.append("    rateLines: ").append(toIndentedString(rateLines)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }
}

